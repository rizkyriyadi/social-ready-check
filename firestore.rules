rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user is accessing their own document/resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Check if user is a member of the circle (via subcollection existence)
    function isCircleMember(circleId) {
      return isAuthenticated() && exists(/databases/$(database)/documents/circles/$(circleId)/members/$(request.auth.uid));
    }

    // --- Users Collection ---
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isOwner(userId);

      // Friends Subcollection (Reciprocal)
      match /friends/{friendId} {
        allow read: if isAuthenticated();
        // Owner can manage their list
        allow write: if isOwner(userId);
        // Allow the *other* user to add/remove THEMSELVES (reciprocal logic)
        allow create, delete: if isAuthenticated() && request.auth.uid == friendId;
      }
    }

    // --- Usernames ---
    match /usernames/{username} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.uid == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.uid == request.auth.uid;
    }

    // --- Friend Requests ---
    match /friend_requests/{requestId} {
      // Allow read/write if user is sender or receiver
      allow read, write: if isAuthenticated() && 
        (resource.data.senderId == request.auth.uid || 
         resource.data.receiverId == request.auth.uid ||
         request.resource.data.senderId == request.auth.uid ||
         request.resource.data.receiverId == request.auth.uid);
    }

    // --- Circles (Squads) ---
    match /circles/{circleId} {
      // 1. Browsing/Listing: Allow auth users to read circles
      allow read: if isAuthenticated();
      
      // 2. Creation: Allow auth users to create circles
      allow create: if isAuthenticated();
      
      // 3. Updates: 
      // - Updating metadata/lastMessage (Members)
      // - Joining/Leaving (User adding/removing self from memberIds)
      allow update: if isAuthenticated(); 
      
      // 4. Deletion: Allow owner to delete (e.g. when last member leaves)
      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
      // Refined logic ideally checks if user is in 'memberIds' or adding self.
      
      // Members Subcollection
      match /members/{memberId} {
        allow read: if isAuthenticated();
        // User can write their own member document (Join/Leave)
        // OR the Circle Owner can manage members (e.g. promote new leader)
        allow write: if isOwner(memberId) || 
                     (exists(/databases/$(database)/documents/circles/$(circleId)) && 
                      get(/databases/$(database)/documents/circles/$(circleId)).data.ownerId == request.auth.uid);
      }

      // Messages Subcollection
      match /messages/{messageId} {
        // Only members can read messages
        allow read: if isCircleMember(circleId);
        
        // Create: Members can send messages
        allow create: if isAuthenticated() && (
          // 1. Regular User Message: Must be member (or creating circle) AND sender matches auth
          ((isCircleMember(circleId) || !exists(/databases/$(database)/documents/circles/$(circleId)))
           && request.resource.data.senderId == request.auth.uid)
          ||
          // 2. System Message: Allow 'SYSTEM' sender (used during Join/Leave/Create)
          (request.resource.data.senderId == "SYSTEM" && request.resource.data.type == "SYSTEM")
        );
        
        // Update: Members can update readBy field (for read receipts)
        allow update: if isCircleMember(circleId) && isAuthenticated();
      }

      // Audit Logs Subcollection
      match /audit_logs/{logId} {
        allow read: if isCircleMember(circleId);
        allow create: if isCircleMember(circleId);
      }

      // Summons Subcollection (Ready Check)
      match /summons/{summonId} {
        allow read: if isCircleMember(circleId);
        allow create: if isCircleMember(circleId);
        allow update: if isCircleMember(circleId);
      }
      
      // Typing Subcollection (Real-time typing indicators)
      match /typing/{userId} {
        allow read: if isCircleMember(circleId);
        allow write: if isAuthenticated() && request.auth.uid == userId;
      }

      // Posts Subcollection (Board/Timeline)
      match /posts/{postId} {
        // Members can read all posts
        allow read: if isCircleMember(circleId);
        
        // Members can create posts (author must match)
        allow create: if isCircleMember(circleId) && 
                      request.resource.data.authorId == request.auth.uid;
        
        // Members can update posts (for likes)
        allow update: if isCircleMember(circleId);
        
        // Only author can delete their posts
        allow delete: if isCircleMember(circleId) && 
                      resource.data.authorId == request.auth.uid;

        // Comments Subcollection
        match /comments/{commentId} {
          allow read: if isCircleMember(circleId);
          
          allow create: if isCircleMember(circleId) && 
                        request.resource.data.authorId == request.auth.uid;
          
          allow delete: if isCircleMember(circleId) && 
                        resource.data.authorId == request.auth.uid;
        }
      }
    }


    // --- Direct Messages (Chats) ---
    // Channel ID format: min(uid1, uid2)_max(uid1, uid2)
    match /chats/{channelId} {
      // Helper: Check if user's UID is part of the channel ID
      // Channel ID format: uid1_uid2 where uid1 < uid2 alphabetically
      function isParticipantByChannelId() {
        return isAuthenticated() && (
          channelId.matches(request.auth.uid + '_.*') ||
          channelId.matches('.*_' + request.auth.uid)
        );
      }
      
      // Helper: Check if user is a participant (for existing documents)
      function isDMParticipant() {
        return isAuthenticated() && 
          request.auth.uid in resource.data.participants;
      }
      
      function willBeDMParticipant() {
        return isAuthenticated() && 
          request.auth.uid in request.resource.data.participants;
      }
      
      // Read: Participants can read (check channelId OR participants array)
      allow read: if isParticipantByChannelId() || isDMParticipant();
      
      // Create: Only if user is one of the participants
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.participants &&
        request.resource.data.participants.size() == 2;
      
      // Update: Only participants can update (lastMessage, typing, etc.)
      allow update: if isDMParticipant() || isParticipantByChannelId();
      
      // Delete: Not allowed (soft delete only)
      allow delete: if false;
      
      // Messages Subcollection
      match /messages/{messageId} {
        // Read: Only participants (check by channelId pattern OR parent participants)
        allow read: if isAuthenticated() && (
          channelId.matches(request.auth.uid + '_.*') ||
          channelId.matches('.*_' + request.auth.uid) ||
          request.auth.uid in get(/databases/$(database)/documents/chats/$(channelId)).data.participants
        );
        
        // Create: Sender must be participant AND senderId must match auth
        allow create: if isAuthenticated() && 
          (channelId.matches(request.auth.uid + '_.*') ||
           channelId.matches('.*_' + request.auth.uid)) &&
          (request.resource.data.senderId == request.auth.uid || 
           request.resource.data.senderId == "SYSTEM");
        
        // Update: Only sender can update OR participant can update readBy
        allow update: if isAuthenticated() && (
          resource.data.senderId == request.auth.uid ||
          (channelId.matches(request.auth.uid + '_.*') ||
           channelId.matches('.*_' + request.auth.uid))
        );
      }
      
      // Typing Subcollection
      match /typing/{userId} {
        allow read: if isAuthenticated() && (
          channelId.matches(request.auth.uid + '_.*') ||
          channelId.matches('.*_' + request.auth.uid)
        );
        allow write: if isAuthenticated() && request.auth.uid == userId;
      }
    }
  }
}