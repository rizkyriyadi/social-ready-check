package com.example.tripglide.ui.onboarding

import android.content.Context
import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.example.tripglide.data.repository.AuthRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class OnboardingViewModel(
    private val authRepository: AuthRepository
) : ViewModel() {

    private val _currentStep = MutableStateFlow(0)
    val currentStep: StateFlow<Int> = _currentStep.asStateFlow()

    private val _displayName = MutableStateFlow("")
    val displayName: StateFlow<String> = _displayName.asStateFlow()

    private val _username = MutableStateFlow("")
    val username: StateFlow<String> = _username.asStateFlow()

    private val _photoUrl = MutableStateFlow("")
    val photoUrl: StateFlow<String> = _photoUrl.asStateFlow()

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _usernameError = MutableStateFlow<String?>(null)
    val usernameError: StateFlow<String?> = _usernameError.asStateFlow()
    
    private val _isUsernameAvailable = MutableStateFlow(false)
    val isUsernameAvailable: StateFlow<Boolean> = _isUsernameAvailable.asStateFlow()

    init {
        loadInitialData()
    }

    private fun loadInitialData() {
        viewModelScope.launch {
            val result = authRepository.getUserProfile()
            result.getOrNull()?.let { user ->
                _displayName.value = user.displayName
                _username.value = user.username
                _photoUrl.value = user.photoUrl
                // If username is autogenerated (starts with @), validate it initially? 
                // Or just let user keep it.
                if (user.username.isNotEmpty()) {
                    checkUsername(user.username, initial = true)
                }
            }
        }
    }

    fun onNextStep() {
        if (_currentStep.value < 2) {
            _currentStep.value += 1
        }
    }

    fun onPreviousStep() {
        if (_currentStep.value > 0) {
            _currentStep.value -= 1
        }
    }

    fun updateDisplayName(name: String) {
        _displayName.value = name
    }

    fun updateUsername(input: String) {
        _username.value = input
        checkUsername(input)
    }

    private fun checkUsername(input: String, initial: Boolean = false) {
         viewModelScope.launch {
            if (input.length < 3) {
                _usernameError.value = "Too short"
                _isUsernameAvailable.value = false
                return@launch
            }
            
            // If it's the same as current (initial load), it might be "taken" by us, which is fine.
            // But verify availability excludes "self" logic in Repo? 
            // Our repo check is simple existence. 
            // The completeOnboarding handles idempotency.
            // For UI feedback, if it's our own reserved username, it should be valid.
            
            _usernameError.value = null // Reset for now
            // Debounce could go here
            
            val isAvailable = authRepository.checkUsernameAvailability(input)
            
            // If unavailable, check if we own it? Repo doesn't expose owner easily without fetch.
            // For now, accept that checkUsernameAvailability returns false if WE own it too.
            // We can improve this by checking against _initial_ username.
            // However, for onboarding, we just reserved it.
            
             // Hack: If input matches our loaded username, assume valid
             val currentUser = authRepository.getUserProfile().getOrNull()
             if (currentUser?.username?.lowercase() == input.lowercase()) {
                 _isUsernameAvailable.value = true
                 _usernameError.value = null
             } else {
                 if (isAvailable) {
                     _isUsernameAvailable.value = true
                     _usernameError.value = null
                 } else {
                     _isUsernameAvailable.value = false
                     _usernameError.value = "Username taken"
                 }
             }
         }
    }

    fun uploadPhoto(uri: Uri) {
        viewModelScope.launch {
            _isLoading.value = true
            val result = authRepository.uploadProfileImage(uri)
            if (result.isSuccess) {
                _photoUrl.value = result.getOrNull() ?: ""
            }
            _isLoading.value = false
        }
    }

    fun completeOnboarding(onSuccess: () -> Unit) {
        viewModelScope.launch {
            _isLoading.value = true
            val result = authRepository.completeOnboarding(
                displayName = _displayName.value,
                photoUrl = _photoUrl.value,
                username = _username.value
            )
            _isLoading.value = false
            if (result.isSuccess) {
                onSuccess()
            } else {
                // Show error?
            }
        }
    }
}

class OnboardingViewModelFactory(private val context: Context) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(OnboardingViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return OnboardingViewModel(AuthRepository(context)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}
